<div class="content">
        <div class="intro">
        	<p>Recentemente me interessei por linguagens de programação com paradigmas funcionais, como Common Lisp e Haskell, e isso me levou a estudar cálculo lambda, o qual é o sistema formal teórico que está por trás dessas linguagens e da parte funcional das linguagens multi paradigmas como JavaScript e Python. Este modelo foi proposto por Alonzo Church:</p>
	</div>
        <div class="alonzo-section">
            <img src="https://i.imgur.com/GCzNqxG.jpg" alt="Imagem de Alonzo Church" class="alonzo-image"/>
            <div class="alonzo-text">
                <h2>Alonzo Church (1903 – 1995)</h2>
            	<p>Matemático estado-unidense, professor na universidade de Princeton, onde foi orientador de doutorado de Alan Turing. Ao colocar funções matemáticas em perspectiva com a computação, criou o cálculo lambda.</p>
	    </div>
        </div>
	<div>
		<h2>Cálculo Lambda Vs Máquina de Turing</h2>
		<p>O cálculo lambda, como vimos, foi desenvolvido por Alonzo Church, já a máquina de Turing, sendo a máquina que você está utilizando para ler esse blog, foi inventada posteriormente por Alan Turing. E com o avanço do estudo das funções computáveis, foi descoberto que estes sistemas são formalmente equivalentes, no sentido de que qualquer aplicação escrita para uma máquina de Turing pode ser traduzida para o Cálculo Lambda, isso se dá pelo Teorema de Church-Turing.</p>
		<h2>Sintaxe de cálculo lambda</h2>
		<p>Podemos definir de forma intuitiva a sintaxe do cálculo lambda, composta pela letra λ seguida de uma variável e depois pelo corpo da função definida em termos das variáveis, e então poderíamos escrever algo como:</p>

		<div class="lambda-expression" data-content="1- Função de Sucessor">
			λx.(x + 1)
		</div>

		<div class="lambda-expression" data-content="2- Função de Soma">
			λx.λy.(x + y)
		</div>

		<p>E dessa forma é possível receber inputs e produzir outputs em termos das variáveis do input. Com isso, podemos utilizá-las em uma aplicação substituindo as variáveis por valores:</p>

		<div class="lambda-expression" data-content="Aplicação do exemplo 2">
			<p>λx.λy.(x + y) 5 2</p>
			<p>5 + 2</p>
			<p>7</p>
		</div>

		<p>No entanto, se nosso objetivo for estudar de fato a matemática dura proposta por Church, precisaríamos de definições formais rigorosas, axiomas e tudo mais. Mas, por enquanto, podemos usar essa noção intuitiva para estudar nossos primeiros termos.</p>
		<p>Ainda assim, é possível formalizar brevemente o que são os termos usados no cálculo lambda, pois se trata de um sistema particularmente simples, eles podem ser:</p>
		<ul>
    			<li>Uma variável (x, y, z...)</li>
    			<li>Uma abstração, em que x é uma variável e t é um termo lambda, então λx.t é uma abstração</li>
    			<li>Uma aplicação, em que t e s são termos lambda, então ts é uma aplicação</li>
		</ul>
		<p>Nada mais é termo lambda, e, por isso, os exemplos iniciais não são termos lambdas de verdade, uma vez que "+" não está definido e "1" também não está definido. Na verdade, muitas coisas que queremos usar, como números, valores lógicos, recursividade, nada está definido, no entanto, pode ser codificado usando os termos lambdas.</p>
		<p>Por fim, neste artigo introdutório, podemos codificar os valores lógicos verdadeiro e falso e o operador "não" usando este sistema. Para isso, escrevemos uma abstração que recebe duas variáveis e retorna a primeira ou a segunda se verdadeiro ou se falso repetitivamente.</p>

		<div class="lambda-expression" data-content="VERDADE">
			λx.λy.x
		</div>

		<div class="lambda-expression" data-content="FALSO">
			λx.λy.y
		</div>

		<p>Vamos adotar V para verdade e F para falso. Além disso o operador "<em>não</em>" inverte o valor lógico de verdadeiro para falso, perceba que as funções que criamos trazem a ideia de "escolher" entre duas entradas, usando isso podemos fazer a abstração:</p>

		<div class="lambda-expression" data-content="NÃO">
			λb.b F V
		</div>

		Podemos testar, se fizermos a aplicação "<em>não verdade</em>" devemos receber falso como saída.

		<div class="lambda-expression" data-content="NÃO VERDADE">
			<p>(λb.b F V) V</p>
			<p>(V F V)</p>
			<p>(λx.λy.x)F V</p>
			<p>F</p>
			<p>c.q.d</p>
		</div>


	</div>
</div>
